# uni-verse Project Overview

This document provides an overview of the uni-verse project, generated by the Gemini CLI agent.

## Project Overview

uni-verse is a 2D side-scrolling sandbox game, drawing inspiration from Minecraft and Dwarf Fortress. Its unique aesthetic comes from rendering the game world using Unicode characters within a web browser. The core gameplay loop involves exploring a procedurally generated world, digging for resources, and constructing various structures.

**Key Technologies:**
*   **Language:** JavaScript (ESM)
*   **Core Library:** `rot-js` (for noise generation and display utilities)
*   **Runtime:** Modern Web Browser (client-side rendering via HTML `<canvas>`), Node.js (for the planned multiplayer server phase)
*   **Communication:** WebSockets (for multiplayer)
*   **Testing:** Vitest (test runner), utilizing Node.js's native test runner
*   **Package Management:** npm

**Architecture:**
The project is designed with a future Client-Server model in mind, where a Node.js server will act as the authoritative source of truth for game state, and browser clients will be thin rendering terminals. The codebase emphasizes a "Functional Core, Imperative Shell" approach, promoting pure functions and immutable data structures for core game logic, with side effects isolated at the application boundaries. Game elements are defined using a data-driven design.

**World Generation:**
The world is an "infinite" map generated on-demand in chunks. It employs a multi-pass, layered noise algorithm (Perlin/Simplex) to define elevation, biomes, caves, and to place structures like trees.

**Development Phases:**
The project is planned in two main phases:
1.  **Phase 1 (Single-Player Foundation):** Focuses on developing a playable single-player prototype with client-side logic, structured for future server integration.
2.  **Phase 2 (Multiplayer Refactor):** Involves introducing multiplayer functionality by creating the Node.js server, moving authoritative logic to it, and implementing WebSocket communication.

## Building and Running

### Dependencies
Project dependencies are managed via `npm`. The primary dependency identified is `rot-js`.

### Testing
Tests are run using Node.js's native test runner. Vitest is not used due to compatibility issues on Android.
To run the tests, execute the following command in the project root:
```bash
npm test
```

### Running the Application
There is no explicit `start` or `dev` script defined in `package.json` for running the application directly. Based on the `DESIGN.md`, the game is intended to run in a web browser. For the single-player phase, the game logic is client-side. For the multiplayer phase, a Node.js server will be introduced.

**TODO:** Add instructions for how to run the single-player client in a browser once implemented.

## Development Conventions

**Testing Philosophy:**
The project adheres to a "Testing Without Mocks" philosophy (also known as "Nullables, not Mocks"). This means:
*   Pure functions (e.g., world generation, game state updates) are tested directly by providing input and asserting on the output, without mocks.
*   External dependencies are wrapped in Adapters, and tests use "Fake" implementations of these adapters to verify behavior without side effects.
*   A TDD-style workflow is followed: write a failing test, then write code to make it pass.

**Code Style and Architecture:**
*   **Functional Approach:** Core game logic is implemented as pure functions operating on immutable data structures.
*   **Data-Driven Design:** Game elements (tiles, biomes) are defined as data objects rather than being hardcoded.
*   **Side Effect Isolation:** Side effects (rendering, networking) are isolated at the application's boundaries.

## Workflow Description

This section outlines the typical workflow for contributing to the uni-verse project.

1.  **Understand the Task:** Clearly understand the feature, bug fix, or refactoring task. Refer to issue trackers, design documents, or discussions for context.
2.  **Branching:** Create a new branch from `main` for your changes. Use a descriptive branch name (e.g., `feature/new-biome`, `bugfix/rendering-glitch`).
3.  **Implement and Test:**
    *   Write tests first (TDD approach) for new features or bug fixes.
    *   Implement the changes, adhering to the project's coding conventions and architectural principles (functional core, data-driven, side effect isolation).
    *   Ensure all existing tests pass and new tests cover the implemented functionality.
4.  **Code Review:** Submit a pull request (PR) to the `main` branch. Describe your changes, their impact, and any relevant testing performed.
5.  **Address Feedback:** Respond to code review comments and make necessary adjustments.
6.  **Merge:** Once approved, your changes will be merged into `main`.